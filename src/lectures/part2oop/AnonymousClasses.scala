package lectures.part2oop

object AnonymousClasses extends App {

  abstract class Animal{
    def eat: Unit
  }

  //Anonymous Class : Whenever we instantiate any class(abstract or non-abstract) with on the spot implementation , compiler turns that into an anonymous class.
  val funnyAnimal: Animal = new Animal {
    override def eat: Unit = println("ha ha ha")
  }

  /*
    Above code is equivalent to and is replaced by below code:
    -----------------------------------------------------------
    class AnonymousClasses$$anon$1 extends Animal {
      override def eat: Unit = println("ha ha ha")
    }
    val funnyAnimal: Animal = new AnonymousClasses$$anon$1
    -----------------------------------------------------------
    Compiler does this behind the scenes. Class name is generated by compiler , suffix 1 may change for different class names.
   */

  println(funnyAnimal.getClass)                                                     // prints "class lectures.part2oop.AnonymousClasses$$anon$1".

  class Person(name: String){
    def sayHi: Unit = println(s"Hi , My name is $name, how can I help?")
  }

  //Anonymous class for person : provide on the spot implementation for sayHi method. Also need to pass parameters because under the hood compiler converts this into the code which extends the superclass(as shown above).
  // And if superclass has parameters , subclass has to have parameter. You also need to provide implementations for all the abstract methods and fields (of abstract class or trait) that you instantiate anonymously.
  val jim: Person = new Person("Jim"){
    override def sayHi: Unit = println(s"Hi , My name is Jim , How can I be of service?")
  }

  println(jim.getClass)                                                             // prints "class lectures.part2oop.AnonymousClasses$$anon$2"
}
